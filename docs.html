<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: module main</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head><body bgcolor="#f0f0f8">

<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="#7799ee">
<td valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial">&nbsp;<br><big><big><strong>main</strong></big></big></font></td
><td align=right valign=bottom
><font color="#ffffff" face="helvetica, arial"><a href=".">index</a><br><a href="file:c%3A%5Cusers%5Cdimitris%5Cdesktop%5Claravel_projects%5Cspeach_recognition_github%5Cnode-selectivity-2%5Cmain.py">c:\users\dimitris\desktop\laravel_projects\speach_recognition_github\node-selectivity-2\main.py</a></font></td></tr></table>
    <p></p>
<p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#aa55cc">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Modules</strong></big></font></td></tr>
    
<tr><td bgcolor="#aa55cc"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><table width="100%" summary="list"><tr><td width="25%" valign=top><a href="math.html">math</a><br>
<a href="numpy.html">numpy</a><br>
</td><td width="25%" valign=top><a href="pandas.html">pandas</a><br>
<a href="random.html">random</a><br>
</td><td width="25%" valign=top><a href="simpy.html">simpy</a><br>
<a href="statsmodels.api.html">statsmodels.api</a><br>
</td><td width="25%" valign=top><a href="scipy.stats.html">scipy.stats</a><br>
<a href="time.html">time</a><br>
</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ee77aa">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Classes</strong></big></font></td></tr>
    
<tr><td bgcolor="#ee77aa"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl>
<dt><font face="helvetica, arial"><a href="builtins.html#object">builtins.object</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="main.html#Filter">Filter</a>
</font></dt><dt><font face="helvetica, arial"><a href="main.html#Filter_Vector">Filter_Vector</a>
</font></dt><dt><font face="helvetica, arial"><a href="main.html#Node">Node</a>
</font></dt></dl>
</dd>
</dl>
 <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Filter">class <strong>Filter</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Filter">Filter</a>(env,&nbsp;data_type,&nbsp;min_val,&nbsp;max_val)<br>
&nbsp;<br>
@DESC:&nbsp;Class&nbsp;that&nbsp;represents&nbsp;the&nbsp;different&nbsp;types&nbsp;of&nbsp;data&nbsp;that&nbsp;can&nbsp;occupy&nbsp;the&nbsp;nodes<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Filter-__init__"><strong>__init__</strong></a>(self, env, data_type, min_val, max_val)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Filter_Vector">class <strong>Filter_Vector</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Filter_Vector">Filter_Vector</a>(env,&nbsp;timestamp,&nbsp;filters)<br>
&nbsp;<br>
@DESC:&nbsp;Class&nbsp;that&nbsp;represents&nbsp;a&nbsp;filter&nbsp;vector&nbsp;at&nbsp;a&nbsp;specific&nbsp;timestamp<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Filter_Vector-__init__"><strong>__init__</strong></a>(self, env, timestamp, filters)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Node">class <strong>Node</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Node">Node</a>(env)<br>
&nbsp;<br>
@DESC:&nbsp;Class&nbsp;that&nbsp;represents&nbsp;a&nbsp;single&nbsp;node&nbsp;instance<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Node-__init__"><strong>__init__</strong></a>(self, env)</dt><dd><tt>@DESC:&nbsp;Initialize&nbsp;the&nbsp;<a href="#Node">Node</a>&nbsp;<a href="builtins.html#object">object</a>&nbsp;with&nbsp;the&nbsp;provided&nbsp;environment.<br>
@PARAMS:&nbsp;env&nbsp;(obj)&nbsp;-&gt;&nbsp;The&nbsp;simpy&nbsp;environment&nbsp;<a href="builtins.html#object">object</a>.</tt></dd></dl>

<dl><dt><a name="Node-add_filter"><strong>add_filter</strong></a>(self, filter_data, timestamp)</dt><dd><tt>@DESC:&nbsp;Add&nbsp;a&nbsp;new&nbsp;filter&nbsp;to&nbsp;the&nbsp;filters_table&nbsp;based&nbsp;on&nbsp;the&nbsp;provided&nbsp;array&nbsp;of&nbsp;pairs.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;the&nbsp;length&nbsp;exceeds&nbsp;5,&nbsp;pop&nbsp;the&nbsp;0th&nbsp;position&nbsp;element.<br>
@PARAMS:&nbsp;filter_data&nbsp;(list)&nbsp;-&gt;&nbsp;An&nbsp;array&nbsp;containing&nbsp;pairs&nbsp;of&nbsp;min&nbsp;and&nbsp;max&nbsp;values&nbsp;for&nbsp;each&nbsp;dimension.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestamp&nbsp;(int)&nbsp;-&gt;&nbsp;The&nbsp;timestamp&nbsp;of&nbsp;the&nbsp;event.</tt></dd></dl>

<dl><dt><a name="Node-calculate_mean_std"><strong>calculate_mean_std</strong></a>(self)</dt><dd><tt>@DESC:&nbsp;&nbsp;&nbsp;Calculate&nbsp;the&nbsp;mean&nbsp;and&nbsp;standard&nbsp;deviation&nbsp;of&nbsp;the&nbsp;values&nbsp;in&nbsp;env_data.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns&nbsp;separate&nbsp;vectors&nbsp;for&nbsp;mean&nbsp;and&nbsp;standard&nbsp;deviation,&nbsp;each&nbsp;with<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;same&nbsp;dimensions&nbsp;as&nbsp;the&nbsp;data.<br>
@RET:&nbsp;&nbsp;&nbsp;&nbsp;Tuple&nbsp;(mean_vector,&nbsp;std_dev_vector),&nbsp;where&nbsp;mean_vector&nbsp;and&nbsp;std_dev_vector<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are&nbsp;arrays&nbsp;containing&nbsp;the&nbsp;mean&nbsp;and&nbsp;standard&nbsp;deviation&nbsp;for&nbsp;each&nbsp;dimension<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;the&nbsp;data.</tt></dd></dl>

<dl><dt><a name="Node-generate_filters"><strong>generate_filters</strong></a>(self, env, df, W)</dt><dd><tt>@DESC:&nbsp;Generate&nbsp;the&nbsp;min&nbsp;max&nbsp;values&nbsp;for&nbsp;each&nbsp;of&nbsp;the&nbsp;types&nbsp;of&nbsp;data&nbsp;and&nbsp;store&nbsp;them&nbsp;in&nbsp;the&nbsp;array<br>
@PARAMs:&nbsp;self&nbsp;(obj)&nbsp;&nbsp;&nbsp;-&gt;&nbsp;The&nbsp;<a href="#Node">Node</a>&nbsp;<a href="builtins.html#object">object</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env&nbsp;&nbsp;(obj)&nbsp;&nbsp;&nbsp;-&gt;&nbsp;The&nbsp;simpy&nbsp;env&nbsp;clock<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;df&nbsp;&nbsp;&nbsp;(obj)&nbsp;&nbsp;&nbsp;-&gt;&nbsp;The&nbsp;DataFrame&nbsp;containing&nbsp;the&nbsp;data</tt></dd></dl>

<dl><dt><a name="Node-generate_valid_vector"><strong>generate_valid_vector</strong></a>(self)</dt><dd><tt>@DESC:&nbsp;Generate&nbsp;a&nbsp;valid&nbsp;vector&nbsp;containing&nbsp;random&nbsp;values&nbsp;within&nbsp;the&nbsp;specified&nbsp;min-max&nbsp;ranges&nbsp;for&nbsp;each&nbsp;data&nbsp;type&nbsp;defined&nbsp;in&nbsp;filters_table.<br>
@PARAMs:&nbsp;self&nbsp;(obj)&nbsp;-&gt;&nbsp;The&nbsp;<a href="#Node">Node</a>&nbsp;<a href="builtins.html#object">object</a>.<br>
@RET:&nbsp;vector&nbsp;(list)&nbsp;-&gt;&nbsp;A&nbsp;list&nbsp;containing&nbsp;random&nbsp;values&nbsp;within&nbsp;the&nbsp;specified&nbsp;ranges.</tt></dd></dl>

<dl><dt><a name="Node-is_within_filters"><strong>is_within_filters</strong></a>(self, vector)</dt><dd><tt>@DESC:&nbsp;&nbsp;&nbsp;Checks&nbsp;if&nbsp;the&nbsp;vector_value&nbsp;is&nbsp;within&nbsp;the&nbsp;min-max&nbsp;ranges&nbsp;specified<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;the&nbsp;last/most&nbsp;recent&nbsp;filter&nbsp;in&nbsp;the&nbsp;filter_vectors_table.<br>
@PARAMS:&nbsp;vector_value&nbsp;(list)&nbsp;-&gt;&nbsp;The&nbsp;vector&nbsp;value&nbsp;to&nbsp;check.<br>
@RET:&nbsp;&nbsp;&nbsp;&nbsp;int.&nbsp;Returns&nbsp;0&nbsp;if&nbsp;the&nbsp;vector&nbsp;is&nbsp;outside&nbsp;the&nbsp;specified&nbsp;ranges&nbsp;for&nbsp;any<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dimension,&nbsp;returns&nbsp;1&nbsp;if&nbsp;all&nbsp;dimensions&nbsp;are&nbsp;within&nbsp;the&nbsp;specified&nbsp;ranges.</tt></dd></dl>

<dl><dt><a name="Node-populate_env_data"><strong>populate_env_data</strong></a>(self, num_vectors, df)</dt><dd><tt>@DESC:&nbsp;Populate&nbsp;the&nbsp;env_data&nbsp;list&nbsp;with&nbsp;a&nbsp;specified&nbsp;number&nbsp;of&nbsp;random&nbsp;vectors.<br>
@PARAMs:&nbsp;self&nbsp;(obj)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;The&nbsp;<a href="#Node">Node</a>&nbsp;<a href="builtins.html#object">object</a>.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_vectors&nbsp;(int)&nbsp;-&gt;&nbsp;The&nbsp;number&nbsp;of&nbsp;random&nbsp;vectors&nbsp;to&nbsp;generate&nbsp;and&nbsp;append&nbsp;to&nbsp;env_data.</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#eeaa77">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Functions</strong></big></font></td></tr>
    
<tr><td bgcolor="#eeaa77"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl><dt><a name="-aggregate_overlaps"><strong>aggregate_overlaps</strong></a>(statistical_overlaps, ml_overlaps)</dt><dd><tt>@DESC:&nbsp;&nbsp;&nbsp;Aggregate&nbsp;two&nbsp;dictionaries&nbsp;by&nbsp;calculating&nbsp;the&nbsp;average&nbsp;for&nbsp;each&nbsp;key.<br>
@PARAMS:&nbsp;statistical_overlaps&nbsp;(dict)&nbsp;-&gt;&nbsp;Dictionary&nbsp;containing&nbsp;statistical&nbsp;overlaps.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ml_overlaps&nbsp;(dict)&nbsp;-&gt;&nbsp;Dictionary&nbsp;containing&nbsp;overlaps&nbsp;from&nbsp;machine&nbsp;learning.<br>
@RET:&nbsp;&nbsp;&nbsp;&nbsp;dict&nbsp;-&gt;&nbsp;A&nbsp;dictionary&nbsp;where&nbsp;the&nbsp;index&nbsp;serves&nbsp;as&nbsp;the&nbsp;key&nbsp;and&nbsp;the&nbsp;symmetric&nbsp;average&nbsp;overlap&nbsp;serves&nbsp;as&nbsp;the&nbsp;value.</tt></dd></dl>
 <dl><dt><a name="-aggregate_statistical_results"><strong>aggregate_statistical_results</strong></a>(overlap_values, future_intervals)</dt><dd><tt>@DESC:&nbsp;Aggregate&nbsp;the&nbsp;results&nbsp;of&nbsp;statistical&nbsp;overlap&nbsp;and&nbsp;future&nbsp;intervals.<br>
@PARAMS:&nbsp;overlap_values&nbsp;(dict)&nbsp;-&gt;&nbsp;Dictionary&nbsp;containing&nbsp;overlap&nbsp;values&nbsp;for&nbsp;each&nbsp;node.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;future_intervals&nbsp;(dict)&nbsp;-&gt;&nbsp;Dictionary&nbsp;containing&nbsp;future&nbsp;intervals&nbsp;for&nbsp;each&nbsp;node.<br>
@RET:&nbsp;dict&nbsp;-&gt;&nbsp;Dictionary&nbsp;containing&nbsp;aggregated&nbsp;results&nbsp;for&nbsp;each&nbsp;node.</tt></dd></dl>
 <dl><dt><a name="-calculate_current_overlaps"><strong>calculate_current_overlaps</strong></a>(env, nodes, min_max_values_array)</dt><dd><tt>@DESC:&nbsp;&nbsp;&nbsp;Calculate&nbsp;the&nbsp;current&nbsp;overlap&nbsp;between&nbsp;the&nbsp;filters&nbsp;in&nbsp;nodes.filters_table&nbsp;and<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;corresponding&nbsp;elements&nbsp;in&nbsp;the&nbsp;random_vector&nbsp;for&nbsp;each&nbsp;node.<br>
@PARAMS:&nbsp;env&nbsp;(obj)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;The&nbsp;SimPy&nbsp;environment.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodes&nbsp;(list&nbsp;of&nbsp;<a href="#Node">Node</a>)&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;List&nbsp;of&nbsp;<a href="#Node">Node</a>&nbsp;objects.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;random_vector&nbsp;(list)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;The&nbsp;N-length&nbsp;array&nbsp;for&nbsp;calculating&nbsp;overlap.<br>
@RET:&nbsp;&nbsp;&nbsp;&nbsp;list&nbsp;of&nbsp;tuples&nbsp;-&gt;&nbsp;Each&nbsp;tuple&nbsp;contains&nbsp;the&nbsp;node&nbsp;index&nbsp;and&nbsp;the&nbsp;corresponding&nbsp;total&nbsp;overlap.</tt></dd></dl>
 <dl><dt><a name="-calculate_element_overlap"><strong>calculate_element_overlap</strong></a>(min_val, max_val, interval_start, interval_end)</dt><dd><tt>@DESC:&nbsp;&nbsp;&nbsp;Calculate&nbsp;the&nbsp;overlap&nbsp;between&nbsp;an&nbsp;element&nbsp;(min_val,&nbsp;max_val)&nbsp;and&nbsp;an&nbsp;interval.<br>
@PARAMS:&nbsp;min_val&nbsp;(float)&nbsp;-&gt;&nbsp;The&nbsp;minimum&nbsp;value&nbsp;of&nbsp;the&nbsp;element.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_val&nbsp;(float)&nbsp;-&gt;&nbsp;The&nbsp;maximum&nbsp;value&nbsp;of&nbsp;the&nbsp;element.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interval_start&nbsp;(float)&nbsp;-&gt;&nbsp;The&nbsp;start&nbsp;of&nbsp;the&nbsp;interval.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interval_end&nbsp;(float)&nbsp;-&gt;&nbsp;The&nbsp;end&nbsp;of&nbsp;the&nbsp;interval.<br>
@RET:&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;-&gt;&nbsp;The&nbsp;calculated&nbsp;overlap&nbsp;value&nbsp;for&nbsp;the&nbsp;element&nbsp;and&nbsp;interval.</tt></dd></dl>
 <dl><dt><a name="-calculate_future_intervals"><strong>calculate_future_intervals</strong></a>(nodes)</dt><dd><tt>@DESC:&nbsp;Calculate&nbsp;the&nbsp;future&nbsp;intervals&nbsp;for&nbsp;each&nbsp;node&nbsp;based&nbsp;on&nbsp;the&nbsp;filter&nbsp;vectors.<br>
@PARAMS:&nbsp;nodes&nbsp;(list)&nbsp;-&gt;&nbsp;List&nbsp;of&nbsp;nodes&nbsp;containing&nbsp;filter&nbsp;vectors.<br>
@RET:&nbsp;dict&nbsp;-&gt;&nbsp;Dictionary&nbsp;containing&nbsp;the&nbsp;prediction&nbsp;intervals&nbsp;for&nbsp;each&nbsp;node&nbsp;and&nbsp;dimension.</tt></dd></dl>
 <dl><dt><a name="-calculate_interval_overlap"><strong>calculate_interval_overlap</strong></a>(interval, min_max_values_array)</dt><dd><tt>@DESC:&nbsp;&nbsp;&nbsp;Calculate&nbsp;the&nbsp;overlap&nbsp;between&nbsp;an&nbsp;interval&nbsp;and&nbsp;the&nbsp;min_max_values_array.<br>
@PARAMS:&nbsp;interval&nbsp;(tuple)&nbsp;-&gt;&nbsp;The&nbsp;interval&nbsp;to&nbsp;calculate&nbsp;overlap&nbsp;for.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_max_values_array&nbsp;(list)&nbsp;-&gt;&nbsp;The&nbsp;N-length&nbsp;array&nbsp;for&nbsp;calculating&nbsp;overlap.<br>
@RET:&nbsp;&nbsp;&nbsp;&nbsp;list&nbsp;-&gt;&nbsp;The&nbsp;calculated&nbsp;overlap&nbsp;values&nbsp;for&nbsp;the&nbsp;interval.</tt></dd></dl>
 <dl><dt><a name="-calculate_intervals_overlap"><strong>calculate_intervals_overlap</strong></a>(future_intervals, min_max_values_array)</dt><dd><tt>@DESC:&nbsp;&nbsp;&nbsp;Calculate&nbsp;the&nbsp;overlap&nbsp;between&nbsp;future&nbsp;intervals&nbsp;and&nbsp;the&nbsp;corresponding<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements&nbsp;in&nbsp;the&nbsp;min_max_values_array.<br>
@PARAMS:&nbsp;future_intervals&nbsp;(dict)&nbsp;-&gt;&nbsp;Dictionary&nbsp;containing&nbsp;future&nbsp;intervals&nbsp;for&nbsp;each&nbsp;node.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_max_values_array&nbsp;(list)&nbsp;-&gt;&nbsp;The&nbsp;N-length&nbsp;array&nbsp;for&nbsp;calculating&nbsp;overlap.<br>
@RET:&nbsp;&nbsp;&nbsp;&nbsp;list&nbsp;of&nbsp;lists&nbsp;-&gt;&nbsp;Each&nbsp;inner&nbsp;list&nbsp;contains&nbsp;the&nbsp;overlap&nbsp;values&nbsp;for&nbsp;one&nbsp;interval.</tt></dd></dl>
 <dl><dt><a name="-calculate_min_max_values"><strong>calculate_min_max_values</strong></a>(random_vector_array)</dt><dd><tt>@DESC:&nbsp;&nbsp;&nbsp;Calculate&nbsp;the&nbsp;minimum&nbsp;and&nbsp;maximum&nbsp;values&nbsp;for&nbsp;each&nbsp;dimension&nbsp;in&nbsp;the&nbsp;input&nbsp;array.<br>
@PARAMS:&nbsp;random_vector_array&nbsp;(list)&nbsp;-&gt;&nbsp;The&nbsp;input&nbsp;array&nbsp;containing&nbsp;random&nbsp;vectors.<br>
@RET:&nbsp;&nbsp;&nbsp;&nbsp;list&nbsp;-&gt;&nbsp;A&nbsp;list&nbsp;containing&nbsp;the&nbsp;minimum&nbsp;and&nbsp;maximum&nbsp;values&nbsp;for&nbsp;each&nbsp;dimension.</tt></dd></dl>
 <dl><dt><a name="-calculate_node_overlap"><strong>calculate_node_overlap</strong></a>(filter_vectors_table, min_max_values_array)</dt><dd><tt>@DESC:&nbsp;&nbsp;&nbsp;Calculate&nbsp;the&nbsp;overlap&nbsp;between&nbsp;the&nbsp;filters&nbsp;in&nbsp;filters_table&nbsp;and&nbsp;the&nbsp;corresponding<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements&nbsp;in&nbsp;the&nbsp;random_vector&nbsp;for&nbsp;a&nbsp;specific&nbsp;node.<br>
@PARAMS:&nbsp;filters_table&nbsp;(list)&nbsp;&nbsp;&nbsp;-&gt;&nbsp;The&nbsp;filters&nbsp;table&nbsp;for&nbsp;a&nbsp;specific&nbsp;node.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;random_vector&nbsp;(list)&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;The&nbsp;N-length&nbsp;array&nbsp;for&nbsp;calculating&nbsp;overlap.<br>
@RET:&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;-&gt;&nbsp;The&nbsp;calculated&nbsp;overlap&nbsp;value&nbsp;for&nbsp;the&nbsp;node.</tt></dd></dl>
 <dl><dt><a name="-calculate_quantile_regression_for_nodes"><strong>calculate_quantile_regression_for_nodes</strong></a>(nodes, min_max_array)</dt><dd><tt>@DESC:&nbsp;Calculate&nbsp;quantile&nbsp;regression&nbsp;for&nbsp;nodes.<br>
@PARAMS:&nbsp;nodes&nbsp;(list)&nbsp;-&gt;&nbsp;List&nbsp;of&nbsp;nodes&nbsp;containing&nbsp;filter&nbsp;vectors.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_max_array&nbsp;(array-like)&nbsp;-&gt;&nbsp;Array&nbsp;with&nbsp;min&nbsp;and&nbsp;max&nbsp;values&nbsp;for&nbsp;prediction.<br>
@RET:&nbsp;dict&nbsp;-&gt;&nbsp;Results&nbsp;of&nbsp;quantile&nbsp;regression&nbsp;for&nbsp;each&nbsp;node&nbsp;and&nbsp;dimension.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node_index:&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dimension_index:&nbsp;[<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'quantile_params':&nbsp;Quantile&nbsp;regression&nbsp;parameters,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'low_res':&nbsp;Predicted&nbsp;values&nbsp;for&nbsp;low&nbsp;dimension,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'high_res':&nbsp;Predicted&nbsp;values&nbsp;for&nbsp;high&nbsp;dimension<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</tt></dd></dl>
 <dl><dt><a name="-calculate_quantile_results_overlap"><strong>calculate_quantile_results_overlap</strong></a>(quant_results, min_max_values_array)</dt><dd><tt>@DESC:&nbsp;&nbsp;&nbsp;Calculate&nbsp;the&nbsp;overlap&nbsp;between&nbsp;quantile&nbsp;results&nbsp;and&nbsp;the&nbsp;corresponding<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements&nbsp;in&nbsp;the&nbsp;min_max_values_array.<br>
@PARAMS:&nbsp;quant_results&nbsp;(dict)&nbsp;-&gt;&nbsp;Dictionary&nbsp;containing&nbsp;quantile&nbsp;results&nbsp;for&nbsp;each&nbsp;node.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_max_values_array&nbsp;(list)&nbsp;-&gt;&nbsp;The&nbsp;N-length&nbsp;array&nbsp;for&nbsp;calculating&nbsp;overlap.<br>
@RET:&nbsp;&nbsp;&nbsp;&nbsp;list&nbsp;of&nbsp;lists&nbsp;-&gt;&nbsp;Each&nbsp;inner&nbsp;list&nbsp;contains&nbsp;the&nbsp;overlap&nbsp;values&nbsp;for&nbsp;one&nbsp;node's&nbsp;quantile&nbsp;results.</tt></dd></dl>
 <dl><dt><a name="-data_selectivity"><strong>data_selectivity</strong></a>(env, nodes, PACKET_NUMBER, PACKET_THRESHOLD, data_df, K, NOD, NUMBER_OF_FILTERS, DIM)</dt><dd><tt>@DESC:&nbsp;&nbsp;&nbsp;&nbsp;Simulates&nbsp;the&nbsp;selectivity&nbsp;of&nbsp;data&nbsp;in&nbsp;edge&nbsp;computing&nbsp;environments<br>
@PARAMS:&nbsp;&nbsp;env&nbsp;(simpy.Environment)&nbsp;-&gt;&nbsp;the&nbsp;simulation&nbsp;environment<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodes&nbsp;(list)&nbsp;-&gt;&nbsp;the&nbsp;list&nbsp;of&nbsp;nodes&nbsp;to&nbsp;simulate<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PACKET_NUMBER&nbsp;(int)&nbsp;-&gt;&nbsp;the&nbsp;number&nbsp;of&nbsp;packets&nbsp;to&nbsp;simulate</tt></dd></dl>
 <dl><dt><a name="-generate_random_multivariable_vector"><strong>generate_random_multivariable_vector</strong></a>(df)</dt><dd><tt>@DESC:&nbsp;Generate&nbsp;a&nbsp;random&nbsp;vector&nbsp;to&nbsp;be&nbsp;filtered<br>
@RET:&nbsp;&nbsp;(list)</tt></dd></dl>
 <dl><dt><a name="-ml_overlap_aggregation"><strong>ml_overlap_aggregation</strong></a>(ml_overlaps)</dt><dd><tt>@DESC:&nbsp;&nbsp;&nbsp;Calculate&nbsp;the&nbsp;statistical&nbsp;overlap&nbsp;for&nbsp;each&nbsp;row&nbsp;in&nbsp;the&nbsp;future&nbsp;overlaps&nbsp;table.<br>
@PARAMS:&nbsp;future_overlaps&nbsp;(list&nbsp;of&nbsp;lists)&nbsp;-&gt;&nbsp;List&nbsp;of&nbsp;lists&nbsp;where&nbsp;each&nbsp;inner&nbsp;list&nbsp;represents&nbsp;overlap&nbsp;values&nbsp;for&nbsp;future&nbsp;intervals.<br>
@RET:&nbsp;&nbsp;&nbsp;&nbsp;dict&nbsp;-&gt;&nbsp;A&nbsp;dictionary&nbsp;where&nbsp;the&nbsp;index&nbsp;serves&nbsp;as&nbsp;the&nbsp;key&nbsp;and&nbsp;the&nbsp;symmetric&nbsp;average&nbsp;overlap&nbsp;serves&nbsp;as&nbsp;the&nbsp;value.</tt></dd></dl>
 <dl><dt><a name="-random_node_choice"><strong>random_node_choice</strong></a>(nodes)</dt><dd><tt>@DESC:&nbsp;&nbsp;&nbsp;Randomly&nbsp;selects&nbsp;a&nbsp;node&nbsp;from&nbsp;the&nbsp;list&nbsp;of&nbsp;nodes&nbsp;and&nbsp;returns&nbsp;both<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;selected&nbsp;node&nbsp;and&nbsp;its&nbsp;index.<br>
@RET:&nbsp;&nbsp;&nbsp;&nbsp;Tuple&nbsp;(selected_node,&nbsp;index),&nbsp;where&nbsp;selected_node&nbsp;is&nbsp;a&nbsp;<a href="#Node">Node</a>&nbsp;instance<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;index&nbsp;is&nbsp;its&nbsp;index&nbsp;in&nbsp;the&nbsp;list&nbsp;of&nbsp;nodes.</tt></dd></dl>
 <dl><dt><a name="-retrieve_sequential_rows"><strong>retrieve_sequential_rows</strong></a>(df, quantity, start_index=None)</dt><dd><tt>@DESC:&nbsp;Retrieve&nbsp;a&nbsp;sequence&nbsp;of&nbsp;quantity&nbsp;rows&nbsp;from&nbsp;the&nbsp;DataFrame&nbsp;starting&nbsp;from&nbsp;the&nbsp;specified&nbsp;index.<br>
@PARAMS:&nbsp;df&nbsp;(DataFrame)&nbsp;-&gt;&nbsp;The&nbsp;DataFrame&nbsp;to&nbsp;retrieve&nbsp;rows&nbsp;from.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quantity&nbsp;(int)&nbsp;-&gt;&nbsp;The&nbsp;number&nbsp;of&nbsp;rows&nbsp;to&nbsp;retrieve.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start_index&nbsp;(int)&nbsp;-&gt;&nbsp;The&nbsp;starting&nbsp;index&nbsp;for&nbsp;the&nbsp;sequence&nbsp;of&nbsp;rows.<br>
@RET:&nbsp;DataFrame&nbsp;-&gt;&nbsp;The&nbsp;sequence&nbsp;of&nbsp;quantity&nbsp;rows&nbsp;starting&nbsp;from&nbsp;the&nbsp;specified&nbsp;index.</tt></dd></dl>
 <dl><dt><a name="-statistical_overlap_calculation"><strong>statistical_overlap_calculation</strong></a>(node_overlaps, future_overlaps)</dt><dd><tt>@DESC:&nbsp;&nbsp;&nbsp;Calculate&nbsp;the&nbsp;statistical&nbsp;overlap&nbsp;between&nbsp;corresponding&nbsp;rows&nbsp;of&nbsp;node&nbsp;overlaps&nbsp;and&nbsp;future&nbsp;overlaps.<br>
@PARAMS:&nbsp;node_overlaps&nbsp;(list&nbsp;of&nbsp;tuples)&nbsp;-&gt;&nbsp;List&nbsp;containing&nbsp;tuples&nbsp;where&nbsp;each&nbsp;tuple&nbsp;contains&nbsp;an&nbsp;index&nbsp;and&nbsp;an&nbsp;array&nbsp;of&nbsp;overlap&nbsp;values.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;future_overlaps&nbsp;(list&nbsp;of&nbsp;lists)&nbsp;-&gt;&nbsp;List&nbsp;of&nbsp;lists&nbsp;where&nbsp;each&nbsp;inner&nbsp;list&nbsp;represents&nbsp;overlap&nbsp;values&nbsp;for&nbsp;future&nbsp;intervals.<br>
@RET:&nbsp;&nbsp;&nbsp;&nbsp;dict&nbsp;-&gt;&nbsp;A&nbsp;dictionary&nbsp;where&nbsp;the&nbsp;index&nbsp;from&nbsp;node_overlaps&nbsp;serves&nbsp;as&nbsp;the&nbsp;key&nbsp;and&nbsp;the&nbsp;symmetric&nbsp;average&nbsp;overlap&nbsp;serves&nbsp;as&nbsp;the&nbsp;value.</tt></dd></dl>
 <dl><dt><a name="-update_stats"><strong>update_stats</strong></a>(node, vector)</dt><dd><tt>@DESC:&nbsp;&nbsp;&nbsp;Update&nbsp;the&nbsp;variables&nbsp;accounted&nbsp;for&nbsp;the&nbsp;statistics&nbsp;of&nbsp;the&nbsp;sim<br>
@PARAMS:&nbsp;node&nbsp;(obj)&nbsp;&nbsp;&nbsp;-&gt;&nbsp;The&nbsp;node&nbsp;obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vector_value&nbsp;&nbsp;-&gt;&nbsp;the&nbsp;random&nbsp;generated&nbsp;vector</tt></dd></dl>
</td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#55aa55">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Data</strong></big></font></td></tr>
    
<tr><td bgcolor="#55aa55"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><strong>K</strong> = 10<br>
<strong>NUMBER_OF_FILTERS</strong> = 5<br>
<strong>NUMBER_OF_NODES</strong> = 10<br>
<strong>NUMBER_OF_NODE_VECTORS</strong> = 10<br>
<strong>PACKET_NUMBER</strong> = 16<br>
<strong>e</strong> = 0<br>
<strong>p</strong> = 0<br>
<strong>q</strong> = 0<br>
<strong>r</strong> = 0<br>
<strong>s</strong> = 0<br>
<strong>t</strong> = []</td></tr></table>
</body></html>